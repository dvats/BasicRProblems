{
  "hash": "3337bd9c9c9691f5adb513c2686e4032",
  "result": {
    "markdown": "# Vectors and matrices\n\nWe divide the book into sections, based on the topics on which the exercises are based.\n\n## Vector based coding\n\nR is most suitable for vector based coding. Which means that many tasks that are done element-wise in languages like C/C++ can be done elegantly in R. Below are some exercises to get you started. A new vector can be declared in many ways, below is my default\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnew <- numeric(length = 5)\nnew\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nnew_again <- c(1,4,6)\n```\n:::\n\n\nOne can access elements of a vector by using square brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnew_again[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nBelow are some practice questions on this topic.\n\n### Questions\n\n1.  Write a function in R to calculate the sum of the first n natural numbers. Verify your result with the formula $\\frac{n(n+1)}{2}$\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum_of_natural_num = function(n)\n    {\n      # use for loop to access every number and sum them one by one in a varibale \n      sum = 0\n      for (i in 1:n)\n      {\n        sum = sum + i\n      }\n      return(sum)\n    }\n    ```\n    :::\n\n\n2.  Write a function in R to calculate the arithmetic mean of a vector of numbers.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    arithmetic_mean = function(vec)\n    {\n      sum = sum(vec)\n      Ar_mean = sum/length(vec)\n      return(Ar_mean)\n    }\n    \n    # another way\n    arithmetic_mean <- function(vec) mean(vec)\n    ```\n    :::\n\n\n    3.  Write a function in R to calculate the variance of a vector of numbers. Verify with the built-in var() function.\n\n3.  Create a vector of the first 500 even integers. Then, calculate the product of all elements in this vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # this is the vector\n    even_seq = seq(from = 2, by = 2 , length.out = 500)\n    # product of the elements\n    prod(even_seq)\n    ```\n    :::\n\n\n4.  Define a vector of the first 1000 numbers in :\n\n    i.  Arithmetic progression of 7 with common difference of 13. That is, create the sequence $a_t$ such that $a_1 = 7$ and $a_{t+1} - a_{t} = 13$ for all $t \\geq 1$.\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        a1 <- 7\n        d <- 13\n        n <- 1000\n        arithmetic_progression <- a1 + (0:(n-1)) * d\n        ```\n        :::\n\n\n    ii. Geometric progression of 7 with common ratio of 1/13. That is, create the sequence $a_t$ such that $a_t = 7$ and $a_{t+1}/a_t = 1/13$\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        a1 <- 7\n        r <- 1/13\n        geometric_progression <- a1 * r^(0:(n-1))\n        ```\n        :::\n\n\n5.  Write a function which generates first `n` numbers in Fibonacci sequence.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    fibonacci_sequence <- function(n) \n    {\n      if (n <= 0) {\n        return(\"Enter a natural number\")  \n      } else if (n == 1) {\n        # The first Fibonacci number\n        return(c(0))  \n      } else if (n == 2) {\n        # The first two Fibonacci numbers\n        return(c(0, 1))  \n      }\n      \n      # Initialize a vector of length n\n      fib <- numeric(n)  \n      fib[1] <- 0  \n      fib[2] <- 1  \n      \n      # Calculate each subsequent Fibonacci number\n      for (i in 3:n) \n      {\n        fib[i] <- fib[i-1] + fib[i-2]  \n      }\n      \n      # return the sequence\n      return(fib)\n    }\n    \n    # Example usage:\n    fibonacci_sequence(10)\n    ```\n    :::\n\n\n6.  Write an R function that takes a numeric vector as input and returns a vector where each element is doubled if it is even, and halved if it is odd.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_vector1 <- function(vec) \n    {\n      n <- length(vec)\n      out <- numeric(length = n)\n      \n      for(i in 1:n)\n      {\n        if(vec[i] %%2 == 0)\n        {\n          out[i] <- 2*vec[i]\n        } else{\n          out[i] <- vec[i]/2\n        }\n      }\n      return(out)\n    }\n    \n    # another method\n    modify_vector2 <- function(vec)\n    {\n      # we can do it in one line using sapply\n      sapply(vec, function(x) if (x %% 2 == 0) x * 2 else x / 2)\n    }\n    \n    # Example usage\n    vec <- c(1, 2, 3, 4, 5)\n    modify_vector1(vec)\n    modify_vector2(vec)\n    ```\n    :::\n\n\n7.  Write a function that takes a numeric vector as input and returns the number of elements that are greater than the mean of the vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    count_greater_than_mean <- function(vec) \n    {\n      mean_val <- mean(vec)\n      sum(vec > mean_val)\n    }\n    \n    # Example usage\n    vec <- c(1, 2, 3, 4, 5, 10, 30)\n    count_greater_than_mean(vec)\n    ```\n    :::\n\n\n8.  \n\n## Matrices\n\nMatrices in R are described by its rows and columns. To define a matrix, we may use the `matrix` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmat <- matrix(c(1,5,8,3,4,0), nrow = 3, ncol = 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    5    4\n[3,]    8    0\n```\n:::\n:::\n\n\nAccessing elements of the matrix can be done using square brackets (with two index placeholders)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmat[1,2] # first row, 2nd column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmat[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n### Questions\n\n1.  Write an R function that takes any n x n matrix and returns the sum of the elements in the upper triangular part of the matrix (excluding the diagonal)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    {r eval=FALSE}\n    \n    sum_upper_triangular <- function(mat) {\n      if (!is.matrix(mat) || nrow(mat) != ncol(mat)) {\n        stop(\"Input must be a square matrix\")\n      }\n      \n      n <- nrow(mat)\n      sum_upper <- 0\n      \n      for (i in 1:(n-1)) {\n        for (j in (i+1):n) {\n          sum_upper <- sum_upper + mat[i, j]\n        }\n      }\n      \n      return(sum_upper)\n    }\n    \n    # Example usage\n    mat <- matrix(1:25, nrow = 5, ncol = 5)\n    mat\n    sum_upper_triangular(mat)\n    ```\n    :::\n\n\n2.  Define a 6×6 matrix with each element being the product of its row and column indices. Extract the submatrix from rows 2 to 4 and columns 3 to 5, and then calculate its inverse.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat <- matrix(0, nrow = 6, ncol = 6)\n    for (i in 1:6) {\n      for (j in 1:6) {\n        mat[i, j] <- i * j\n      }\n    }\n    \n    # Extract submatrix from rows 2 to 5 and columns 3 to 5\n    submat <- mat[2:4, 3:5]\n    \n    # Calculate the inverse of the submatrix\n    #inverse_submat <- solve(submat)\n    \n    # Display the inverse\n    #inverse_submat\n    ```\n    :::\n\n\n3.  Define a 10×10 matrix with all elements being the number 7. Then, replace the diagonal elements with the first 10 powers of 2.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Create a 10x10 matrix with all elements being 7\n    mat <- matrix(7, nrow = 10, ncol = 10)\n    \n    # Replace diagonal elements with the first 10 powers of 2\n    diag(mat) <- 2^(0:9)\n    \n    # Display the matrix\n    mat\n    ```\n    :::\n\n\n## Simulations\n\n1.  Write a function that simulates rolling two fair dice `n` times and returns the proportion of times the sum of the dice is 7.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    roll_dice_simulation <- function(n) \n    {\n      # Simulate rolling two dice n times\n      dice1 <- sample(1:6, n, replace = TRUE)\n      dice2 <- sample(1:6, n, replace = TRUE)\n      \n      # Calculate the sum of the two dice for each roll\n      sum_of_dice <- dice1 + dice2\n      \n      # Count the number of times the sum is 7\n      count_seven <- sum(sum_of_dice == 7)\n      \n      # Calculate the proportion of times the sum is 7\n      proportion_seven <- count_seven / n\n      \n      return(proportion_seven)\n    }\n    \n    # Example usage:\n    roll_dice_simulation(n = 50)\n    ```\n    :::\n\n\n2.  Write a function that simulates tossing a fair coin 20 times and returns the proportion of heads.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    coin_toss_proportion <- function() {\n      tosses <- sample(c(\"H\", \"T\"), size = 20, replace = TRUE)\n      proportion_heads <- sum(tosses == \"H\") / 20\n      return(proportion_heads)\n    }\n    \n    # Example usage\n    set.seed(123)  # For reproducibility\n    coin_toss_proportion()\n    ```\n    :::\n\n\n3.  Write function that simulates rolling two fair dice `n = 100` times and returns the distribution of the sums of the dice. Plot a histogram of the distribution. Now change values of `n`, and see the change in histogram\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    prop_diesum = function(n)\n    { \n      #initialise the frequency table \n      diesum= rep(0 ,12 )\n      for( i in 1:n)\n      {\n        #take a random sample from die\n        die1  = sample(1:6 , size = 1)\n        die2  = sample(1:6 , size = 1)\n        outcome= die1+die2\n        \n        #add the outcome to corresponding frequency table\n        diesum[outcome] = diesum[outcome] + 1\n      }\n      return(diesum)\n    }\n    \n    #calculate frequencies for different n \n    ds1e2 = prop_diesum(100)\n    ds1e3 = prop_diesum(1e3)\n    ds1e4 = prop_diesum(1e4)\n    \n    # make plots (side-by-side)\n    \n    par(mfrow = c(1,3))\n    barplot(ds1e2, main = \"Frequency of Dice Sum (n = 100)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"skyblue\", names.arg = 1:12)\n    \n    barplot(ds1e3, main = \"Frequency of Dice Sum (n = 1000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"lightgreen\", names.arg = 1:12)\n    \n    barplot(ds1e4, main = \"Frequency of Dice Sum (n = 10000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"salmon\", names.arg = 1:12)\n    ```\n    :::\n\n\n4.  Write R simulation function `rolls()` for a fair die is rolled `n` times that returns 1 if at least 1 of the 6 values never appears and 0 otherwise. Then find the average value by running this 1000 times.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rolls = function(n)\n    { \n      #initialise the frequency table \n      die = rep( 0 , 6)\n      for( i in 1:n)\n      {\n        #take a random sample from die\n        outcome = sample(1:6, size = 1) \n        #add the outcome to corresponding frequency table\n        die[outcome] = die[outcome] + 1\n      }\n      #atleast one value never appeared\n      if(min(die) == 0)\n      {\n        count = 1\n      }\n      else #all values appeared atleast ones \n      {\n        count = 0\n      }\n      return(count)\n    }\n    \n    \n    #function to take average\n    expectation = function(num)\n    {\n      store  = numeric(length = 1e3)\n      for( i in 1:1e3)\n      {\n        store[i] = rolls(num)\n      }\n      return(mean(store))\n    }\n    \n    #find the expectation \n    y = numeric(length = 50)\n    for( i in 1:50)\n    {\n      y[i] = expectation(num = i)\n    }\n    \n    #make the plot\n    plot( x = 1:50  , y = y , main = \"Probability vs no of rolls\" , type = \"o\" , col = \"blue\" , ylab = \"Expected Value\" , xlab=\"Rolls\")\n    ```\n    :::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}