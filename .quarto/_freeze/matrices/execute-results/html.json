{
  "hash": "6f25131237bb806c81caef2d48aad970",
  "result": {
    "markdown": "# Matrices\n\nMatrices in R are described by its rows and columns. To define a matrix, we may use the `matrix` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmat <- matrix(c(1,5,8,3,4,0), nrow = 3, ncol = 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    5    4\n[3,]    8    0\n```\n:::\n:::\n\n\nAccessing elements of the matrix can be done using square brackets (with two index placeholders)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmat[1,2] # first row, 2nd column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmat[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Questions\n\n1.  Write an R snippet to create a $10 \\times 10$ matrix where each entry is the product of it's row and column number. i.e. $A_{i,j} = ij$.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    M <- array(0, dim = c(10,10))\n    for (i in 1:10)\n    {\n      for(j in 1:10)\n    {\n        M[i,j] = i*j\n      }\n    }\n    # To check your solution\n    M\n    ```\n    :::\n\n\n2.  Write an R snippet that takes in a matrix and returns a vector with all the column sums.\n\n    (Hint: The solution to this problem can be painfully trivial or needlessly complicated.)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Approach - 1\n    column_Sums <- function(M)\n    {\n      dims <- dim(M)\n      cols <- dims[2]\n      sums <- numeric(cols)\n      for(i in 1:cols)\n      {\n        sums[i] = sum(M[,i])\n      }\n      return(sums)\n    }\n    \n    M <- array(1:12,dim = c(4,3))\n    M # Look at M\n    \n    sums <- column_Sums(M)\n    sums # Look at column sums of M\n    \n    # Aliter (Lazy approach)\n    sums <- colSums(M)\n    sums \n    \n    # Remark: Try a benchmark code on both these solutions to the problem, the result may shock you!\n    ```\n    :::\n\n\n    \\\n\n3.  Define a $6 \\times 6$ matrix where each entry is the sum of random roll of two fair dice.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    roll_two_dice <- function()\n    {\n      sum_of_rolls <- sum(sample(1:6, 2, replace = TRUE))\n      return(sum_of_rolls)\n    }\n    values <- replicate(36, roll_two_dice())\n    answer <- matrix(values, nrow = 6)\n    answer\n    ```\n    :::\n\n\n4.  \n\n5.  Write an R function that takes any n x n matrix and returns the sum of the elements in the upper triangular part of the matrix (excluding the diagonal)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum_upper_triangular <- function(mat) {\n      if (!is.matrix(mat) || nrow(mat) != ncol(mat)) {\n        stop(\"Input must be a square matrix\")\n      }\n      \n      n <- nrow(mat)\n      sum_upper <- 0\n      \n      for (i in 1:(n-1)) {\n        for (j in (i+1):n) {\n          sum_upper <- sum_upper + mat[i, j]\n        }\n      }\n      \n      return(sum_upper)\n    }\n    \n    # Example usage\n    mat <- matrix(1:25, nrow = 5, ncol = 5)\n    mat\n    sum_upper_triangular(mat)\n    ```\n    :::\n\n\n    \\\n\n6.  Define a 6×6 matrix with each element being the product of its row and column indices. Extract the submatrix from rows 2 to 4 and columns 3 to 5, and then calculate its inverse.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat <- matrix(0, nrow = 6, ncol = 6)\n    for (i in 1:6) {\n      for (j in 1:6) {\n        mat[i, j] <- i * j\n      }\n    }\n    \n    # Extract submatrix from rows 2 to 5 and columns 3 to 5\n    submat <- mat[2:4, 3:5]\n    \n    # Calculate the inverse of the submatrix\n    #inverse_submat <- solve(submat)\n    \n    # Display the inverse\n    #inverse_submat\n    ```\n    :::\n\n\n    \\\n\n7.  Define a 10×10 matrix with all elements being the number 7. Then, replace the diagonal elements with the first 10 powers of 2.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Create a 10x10 matrix with all elements being 7\n    mat <- matrix(7, nrow = 10, ncol = 10)\n    \n    # Replace diagonal elements with the first 10 powers of 2\n    diag(mat) <- 2^(0:9)\n    \n    # Display the matrix\n    mat\n    ```\n    :::\n\n\n    \\\n\n8.  Create a function in R that takes two matrices as inputs and returns their Hadamard product (element-wise product).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    hadamard_product <- function(mat1, mat2) \n    {\n      # Check if input matrices are of the same dimensions\n      if (dim(mat1) != dim(mat2)) {\n        stop(\"Input matrices must have the same dimensions\")\n      }\n      \n      # Get dimensions of matrices\n      m <- nrow(mat1)\n      n <- ncol(mat1)\n      \n      # Initialize result matrix\n      result <- matrix(0, nrow = m, ncol = n)\n      \n      # Compute Hadamard product element-wise\n      for (i in 1:m) \n      {\n        for (j in 1:n) \n        {\n          result[i, j] <- mat1[i, j] * mat2[i, j]\n        }\n      }\n      \n      return(result)\n    }\n    \n    # Also mat1*mat2 works!\n    ```\n    :::\n\n\n    \\\n\n9.  Write an R function that takes inputs `n` and `ρ`. The function should return an `n x n` identity matrix with `ρ` added to all non-diagonal elements.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    add_rho_to_identity <- function(n, rho) \n    {\n      # Initialize an n x n matrix with zeros\n      mat <- matrix(0, nrow = n, ncol = n)\n      \n      # Fill the matrix to create an identity matrix with rho added to non-diagonal elements\n      for (i in 1:n) \n      {\n        for (j in 1:n) \n        {\n          if (i == j) \n          {\n            mat[i, j] <- 1  # Set diagonal elements to 1\n          } else {\n            mat[i, j] <- rho  # Set non-diagonal elements to rho\n          }\n        }\n      }\n      \n      return(mat)\n    }\n    ```\n    :::\n\n\n    \\\n\n<!-- -->\n\n10. Write an R function that takes a matrix input and returns a smaller matrix with only the intersection of even rows and even columns of the original matrix.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    extract_even_rows_even_cols <- function(mat) \n    {\n      # Determine dimensions of the input matrix\n      nrow_mat <- nrow(mat)\n      ncol_mat <- ncol(mat)\n      \n      # Initialize variables to store indices of even rows and even columns\n      even_rows <- seq(2, nrow_mat, by = 2)\n      even_cols <- seq(2, ncol_mat, by = 2)\n      \n      # Extract submatrix containing only even rows and even columns\n      submat <- mat[even_rows, even_cols]\n      \n      return(submat)\n    }\n    \n    #You can use for loop too\n    ```\n    :::\n\n\n    \\\n\n<!-- -->\n\n11. Define a 3-dimensional array with dimensions `5 × 5 × 5` where the entries are random normal numbers with mean 0 and standard deviation 1.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    generate_random_3d_array <- function(dim1 = 5, dim2 = 5, dim3 = 5) \n    {\n      # Generate random normal numbers\n      data <- rnorm(dim1 * dim2 * dim3, mean = 0, sd = 1)\n      \n      # Create the 3-dimensional array\n      array_3d <- array(data, dim = c(dim1, dim2, dim3))\n      \n      return(array_3d)\n    }\n    ```\n    :::\n\n\n    \\\n\n12. Create a $100\\times100$ matrix `Mat1` with $ij$th entry being $i\\mod j$ for $i\\geq j$ else $j \\mod i$. Check via code is the matrix is Symmetric?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    {r}\n    # Initialize a 100x100 matrix Mat1\n    n <- 100\n    Mat1 <- matrix(0, nrow = n, ncol = n)\n    \n    # Fill in Mat1 according to the specified rules\n    for (i in 1:n) \n    {\n      for (j in 1:n) \n      {\n        if (i >= j) \n        {\n          Mat1[i, j] <- i %% j\n        } else {\n          Mat1[i, j] <- j %% i\n        }\n      }\n    }\n    \n    # Check if Mat1 is symmetric\n    all.equal(Mat1, t(Mat1))\n    ```\n    :::\n\n\n    \\\n\n13. Create a function which given a number n returns a $n\\times n$ matrix in which each $i^{th},j^{th}$ entry is sum of results on rolling a fair die $(i+j)$ times.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    {r}\n    sum_of_throws <- function(k) \n    {\n      # Simulate k throws of a fair die (each throw results in a number from 1 to 6)\n      throws <- sample(1:6, k, replace = TRUE)\n      \n      # Return the sum of these throws\n      return(sum(throws))\n    }\n    \n    # Function to create an n x n matrix with each (i, j) entry as the sum of i+j dice throws\n    dice_sum_matrix <- function(n) \n    {\n      # Initialize the n x n matrix\n      matrix_result <- matrix(0, nrow = n, ncol = n)\n      \n      # Populate the matrix\n      for (i in 1:n) \n      {\n        for (j in 1:n) \n        {\n          matrix_result[i, j] <- sum_of_throws(i + j)\n        }\n      }\n      \n      return(matrix_result)\n    }\n    ```\n    :::\n",
    "supporting": [
      "matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}