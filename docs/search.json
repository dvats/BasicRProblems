[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "As stated in the Preface, the problems in the book have been written by the following students\n\nIndraj Prajapat\nRythm Kumar\nSaee Kamat\nSubham Anand\nYash Bihany\nZehaan Naik\n\nMany problems are fairly standard, and it is possible some problems are from popular books, blogs, discussions, and even chatGPT."
  },
  {
    "objectID": "sims.html",
    "href": "sims.html",
    "title": "Simulations",
    "section": "",
    "text": "Much of what we do in the program and in statistical coding revolves around simulating experiments. This means, repeated a random experiment, potentially many times.\nBelow are some problems on these themes.\n\n\n\nIn a bag, there are 5 red balls, 3 green balls, and 2 blue balls. Write an R function to randomly draw a ball from the bag.\n\n\nCode\ndraw_ball &lt;- function() \n{\n  bag &lt;- c(rep(\"Red\", 5), rep(\"Green\", 3), rep(\"Blue\", 2))\n  return(sample(bag, 1))\n}\n\n\n\n\nSimulate a random walk of 1000 steps and plot the path. A random walk is such that \\(x_0 = 0\\), and \\(x_t = x_{t-1} \\pm 1\\) with equal probability\n\n\nCode\nsimulate_random_walk &lt;- function(steps) \n{\n  walk &lt;- numeric(length = steps)\n  walk[1] &lt;- 0\n  for(t in 2:steps)\n  {\n    choices &lt;- sample(c(-1, 1), 1)\n    walk[t] &lt;- walk[t-1] + choices\n  }\n  plot(walk, type = \"l\", main = \"Random Walk\", xlab = \"Step\", ylab = \"Position\")\n}\nsimulate_random_walk(1000)\n\n\n\n\nWrite a function that simulates rolling two fair dice n times and returns the proportion of times the sum of the dice is 7.\n\n\nCode\nroll_dice_simulation &lt;- function(n) \n{\n  # Simulate rolling two dice n times\n  dice1 &lt;- sample(1:6, n, replace = TRUE)\n  dice2 &lt;- sample(1:6, n, replace = TRUE)\n\n  # Calculate the sum of the two dice for each roll\n  sum_of_dice &lt;- dice1 + dice2\n\n  # Count the number of times the sum is 7\n  count_seven &lt;- sum(sum_of_dice == 7)\n\n  # Calculate the proportion of times the sum is 7\n  proportion_seven &lt;- count_seven / n\n\n  return(proportion_seven)\n}\n\n# Example usage:\nroll_dice_simulation(n = 50)\n\n\n\n\nWrite a function that simulates tossing a fair coin 20 times and returns the proportion of heads.\n\n\nCode\ncoin_toss_proportion &lt;- function() {\n  tosses &lt;- sample(c(\"H\", \"T\"), size = 20, replace = TRUE)\n  proportion_heads &lt;- sum(tosses == \"H\") / 20\n  return(proportion_heads)\n}\n\n# Example usage\nset.seed(123)  # For reproducibility\ncoin_toss_proportion()\n\n\n\n\nWrite function that simulates rolling two fair dice n = 100 times and returns the distribution of the sums of the dice. Plot a histogram of the distribution. Now change values of n, and see the change in histogram\n\n\nCode\nprop_diesum = function(n)\n{ \n  #initialise the frequency table \n  diesum= rep(0 ,12 )\n  for( i in 1:n)\n  {\n    #take a random sample from die\n    die1  = sample(1:6 , size = 1)\n    die2  = sample(1:6 , size = 1)\n    outcome= die1+die2\n\n    #add the outcome to corresponding frequency table\n    diesum[outcome] = diesum[outcome] + 1\n  }\n  return(diesum)\n}\n\n#calculate frequencies for different n \nds1e2 = prop_diesum(100)\nds1e3 = prop_diesum(1e3)\nds1e4 = prop_diesum(1e4)\n\n# make plots (side-by-side)\n\npar(mfrow = c(1,3))\nbarplot(ds1e2, main = \"Frequency of Dice Sum (n = 100)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"skyblue\", names.arg = 1:12)\n\nbarplot(ds1e3, main = \"Frequency of Dice Sum (n = 1000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"lightgreen\", names.arg = 1:12)\n\nbarplot(ds1e4, main = \"Frequency of Dice Sum (n = 10000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"salmon\", names.arg = 1:12)\n\n\n\n\nWrite R simulation function rolls() for a fair die is rolled n times that returns 1 if at least 1 of the 6 values never appears and 0 otherwise. Then find the average value by running this 1000 times.\n\n\nCode\nrolls = function(n)\n{ \n  #initialise the frequency table \n  die = rep( 0 , 6)\n  for( i in 1:n)\n  {\n    #take a random sample from die\n    outcome = sample(1:6, size = 1) \n    #add the outcome to corresponding frequency table\n    die[outcome] = die[outcome] + 1\n  }\n  #atleast one value never appeared\n  if(min(die) == 0)\n  {\n    count = 1\n  }\n  else #all values appeared atleast ones \n  {\n    count = 0\n  }\n  return(count)\n}\n\n\n#function to take average\nexpectation = function(num)\n{\n  store  = numeric(length = 1e3)\n  for( i in 1:1e3)\n  {\n    store[i] = rolls(num)\n  }\n  return(mean(store))\n}\n\n#find the expectation \ny = numeric(length = 50)\nfor( i in 1:50)\n{\n  y[i] = expectation(num = i)\n}\n\n#make the plot\nplot( x = 1:50  , y = y , main = \"Probability vs no of rolls\" , type = \"o\" , col = \"blue\" , ylab = \"Expected Value\" , xlab=\"Rolls\")\n\n\n\n\nZehaan and Aditya are two constantly bickering roommates who always fight for the only available desk in the room. The rule that they have devised is as follows:\nEach morning, they throw two dice, if the sum of the numbers on the resulting faces is a Prime Number then one of them gets the desk else the other. Since the odds are not equally stacked, they flip a coin before this to decide who get’s the prime number odds and who does not.\nWrite an R function to determine who wins this daily struggle. Output: Zehaan or Aditya accordingly\n\n\nCode\ndaily.desk &lt;- function()\n{\n  d1 &lt;- sample(1:6, 1)\n  d2 &lt;- sample(1:6, 1)\n\n  sum.dice &lt;- d1 + d2\n\n  coin &lt;- sample(1:2, 1)\n\n  if (coin == 1){\n    # Zehaan Gets prime odds\n    if (sum.dice %in% c(2,3,5,7,11)){\n      print(\"Zehaan\")\n    }else{\n      print(\"Aditya\")\n    }\n  }else{\n    # Aditya Gets prime odds\n    if (sum.dice %in% c(2,3,5,7,11)){\n      print(\"Aditya\")\n    }else{\n      print(\"Zehaan\")\n    }\n  }\n}\ndaily.desk()\n\n\n\n\nYash, being very lazy, decides to study for his exam on the last day. There are \\(12\\) chapters in total, but due to time constraints, he can only thoroughly study \\(8\\) of them, chosen randomly. In tomorrow’s exam, \\(30\\) questions will be asked. Each question has an independent \\(0.08\\) probability of coming from chapters \\(1\\) to \\(10\\) and a \\(0.1\\) probability of coming from chapters \\(11\\) and \\(12\\) each. Yash can only answer questions from the chapters he studied, with each correct answer scoring \\(+1\\). The passing percentage is \\(70\\%\\). Write an \\(\\text{R}\\) code to determine if Yash will pass the exam. Print “pass” if he does, and “fail” otherwise.\n\n\nCode\ntotal &lt;- 12\nprob_questions &lt;- c(rep(0.08, 10), 0.1, 0.1)\nquestions &lt;- sample(1:total, prob = prob_questions, replace = TRUE, size = 30)\ncanSolve &lt;- sample(1:total, size = 8)\nscore = sum(questions %in% canSolve) / 30\nif(score &gt;= 0.7){\n  print(\"pass\")\n} else{\n  print(\"fail\")\n}"
  },
  {
    "objectID": "sims.html#questions",
    "href": "sims.html#questions",
    "title": "4  Simulations",
    "section": "4.1 Questions",
    "text": "4.1 Questions\n\nIn a bag, there are 5 red balls, 3 green balls, and 2 blue balls. Write an R function to randomly draw a ball from the bag.\n\n\nCode\ndraw_ball &lt;- function() \n{\n  bag &lt;- c(rep(\"Red\", 5), rep(\"Green\", 3), rep(\"Blue\", 2))\n  return(sample(bag, 1))\n}\n\n\n\n\nSimulate a random walk of 1000 steps and plot the path. A random walk is such that \\(x_0 = 0\\), and \\(x_t = x_{t-1} \\pm 1\\) with equal probability\n\n\nCode\nsimulate_random_walk &lt;- function(steps) \n{\n  walk &lt;- numeric(length = steps)\n  walk[1] &lt;- 0\n  for(t in 2:steps)\n  {\n    choices &lt;- sample(c(-1, 1), 1)\n    walk[t] &lt;- walk[t-1] + choices\n  }\n  plot(walk, type = \"l\", main = \"Random Walk\", xlab = \"Step\", ylab = \"Position\")\n}\nsimulate_random_walk(1000)\n\n\n\n\nWrite a function that simulates rolling two fair dice n times and returns the proportion of times the sum of the dice is 7.\n\n\nCode\nroll_dice_simulation &lt;- function(n) \n{\n  # Simulate rolling two dice n times\n  dice1 &lt;- sample(1:6, n, replace = TRUE)\n  dice2 &lt;- sample(1:6, n, replace = TRUE)\n\n  # Calculate the sum of the two dice for each roll\n  sum_of_dice &lt;- dice1 + dice2\n\n  # Count the number of times the sum is 7\n  count_seven &lt;- sum(sum_of_dice == 7)\n\n  # Calculate the proportion of times the sum is 7\n  proportion_seven &lt;- count_seven / n\n\n  return(proportion_seven)\n}\n\n# Example usage:\nroll_dice_simulation(n = 50)\n\n\n\n\nWrite a function that simulates tossing a fair coin 20 times and returns the proportion of heads.\n\n\nCode\ncoin_toss_proportion &lt;- function() {\n  tosses &lt;- sample(c(\"H\", \"T\"), size = 20, replace = TRUE)\n  proportion_heads &lt;- sum(tosses == \"H\") / 20\n  return(proportion_heads)\n}\n\n# Example usage\nset.seed(123)  # For reproducibility\ncoin_toss_proportion()\n\n\n\n\nWrite function that simulates rolling two fair dice n = 100 times and returns the distribution of the sums of the dice. Plot a histogram of the distribution. Now change values of n, and see the change in histogram\n\n\nCode\nprop_diesum = function(n)\n{ \n  #initialise the frequency table \n  diesum= rep(0 ,12 )\n  for( i in 1:n)\n  {\n    #take a random sample from die\n    die1  = sample(1:6 , size = 1)\n    die2  = sample(1:6 , size = 1)\n    outcome= die1+die2\n\n    #add the outcome to corresponding frequency table\n    diesum[outcome] = diesum[outcome] + 1\n  }\n  return(diesum)\n}\n\n#calculate frequencies for different n \nds1e2 = prop_diesum(100)\nds1e3 = prop_diesum(1e3)\nds1e4 = prop_diesum(1e4)\n\n# make plots (side-by-side)\n\npar(mfrow = c(1,3))\nbarplot(ds1e2, main = \"Frequency of Dice Sum (n = 100)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"skyblue\", names.arg = 1:12)\n\nbarplot(ds1e3, main = \"Frequency of Dice Sum (n = 1000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"lightgreen\", names.arg = 1:12)\n\nbarplot(ds1e4, main = \"Frequency of Dice Sum (n = 10000)\", xlab = \"Sum of Dice\", ylab = \"Frequency\", col = \"salmon\", names.arg = 1:12)\n\n\n\n\nWrite R simulation function rolls() for a fair die is rolled n times that returns 1 if at least 1 of the 6 values never appears and 0 otherwise. Then find the average value by running this 1000 times.\n\n\nCode\nrolls = function(n)\n{ \n  #initialise the frequency table \n  die = rep( 0 , 6)\n  for( i in 1:n)\n  {\n    #take a random sample from die\n    outcome = sample(1:6, size = 1) \n    #add the outcome to corresponding frequency table\n    die[outcome] = die[outcome] + 1\n  }\n  #atleast one value never appeared\n  if(min(die) == 0)\n  {\n    count = 1\n  }\n  else #all values appeared atleast ones \n  {\n    count = 0\n  }\n  return(count)\n}\n\n\n#function to take average\nexpectation = function(num)\n{\n  store  = numeric(length = 1e3)\n  for( i in 1:1e3)\n  {\n    store[i] = rolls(num)\n  }\n  return(mean(store))\n}\n\n#find the expectation \ny = numeric(length = 50)\nfor( i in 1:50)\n{\n  y[i] = expectation(num = i)\n}\n\n#make the plot\nplot( x = 1:50  , y = y , main = \"Probability vs no of rolls\" , type = \"o\" , col = \"blue\" , ylab = \"Expected Value\" , xlab=\"Rolls\")\n\n\n\n\nZehaan and Aditya are two constantly bickering roommates who always fight for the only available desk in the room. The rule that they have devised is as follows:\nEach morning, they throw two dice, if the sum of the numbers on the resulting faces is a Prime Number then one of them gets the desk else the other. Since the odds are not equally stacked, they flip a coin before this to decide who get’s the prime number odds and who does not.\nWrite an R function to determine who wins this daily struggle. Output: Zehaan or Aditya accordingly\n\n\nCode\ndaily.desk &lt;- function()\n{\n  d1 &lt;- sample(1:6, 1)\n  d2 &lt;- sample(1:6, 1)\n\n  sum.dice &lt;- d1 + d2\n\n  coin &lt;- sample(1:2, 1)\n\n  if (coin == 1){\n    # Zehaan Gets prime odds\n    if (sum.dice %in% c(2,3,5,7,11)){\n      print(\"Zehaan\")\n    }else{\n      print(\"Aditya\")\n    }\n  }else{\n    # Aditya Gets prime odds\n    if (sum.dice %in% c(2,3,5,7,11)){\n      print(\"Aditya\")\n    }else{\n      print(\"Zehaan\")\n    }\n  }\n}\ndaily.desk()\n\n\n\n\nYash, being very lazy, decides to study for his exam on the last day. There are \\(12\\) chapters in total, but due to time constraints, he can only thoroughly study \\(8\\) of them, chosen randomly. In tomorrow’s exam, \\(30\\) questions will be asked. Each question has an independent \\(0.08\\) probability of coming from chapters \\(1\\) to \\(10\\) and a \\(0.1\\) probability of coming from chapters \\(11\\) and \\(12\\) each. Yash can only answer questions from the chapters he studied, with each correct answer scoring \\(+1\\). The passing percentage is \\(70\\%\\). Write an \\(\\text{R}\\) code to determine if Yash will pass the exam. Print “pass” if he does, and “fail” otherwise.\n\n\nCode\ntotal &lt;- 12\nprob_questions &lt;- c(rep(0.08, 10), 0.1, 0.1)\nquestions &lt;- sample(1:total, prob = prob_questions, replace = TRUE, size = 30)\ncanSolve &lt;- sample(1:total, size = 8)\nscore = sum(questions %in% canSolve) / 30\nif(score &gt;= 0.7){\n  print(\"pass\")\n} else{\n  print(\"fail\")\n}"
  },
  {
    "objectID": "vec_and_mat.html",
    "href": "vec_and_mat.html",
    "title": "Vectors",
    "section": "",
    "text": "R is most suitable for vector based coding. Which means that many tasks that are done element-wise in languages like C/C++ can be done elegantly in R. Below are some exercises to get you started. A new vector can be declared in many ways, below is my default\n\nnew &lt;- numeric(length = 5)\nnew\n\n[1] 0 0 0 0 0\n\nnew_again &lt;- c(1,4,6)\n\nOne can access elements of a vector by using square brackets:\n\nnew_again[3]\n\n[1] 6\n\n\nBelow are some practice questions on this topic.\n\n\n\nWrite an R code to enumerate the squares of the first 100 natural numbers.\n\n\nCode\nnums &lt;- 1:100\nnums^2   # R is vectorized\n\n\n\n\nA sequence “Dancing Numbers” is defined as follows:\nif \\(B_n\\) is even: \\[\nB_{n+1} = \\dfrac{B_{n}}{2}\n\\]\nelse\n\\[\nB_{n+1} = 3B_n - 1\n\\]\nGenerate the first 100 dancing numbers given \\(B_0\\) is 13.\n\n\nCode\nb0 &lt;- 13\n\nB &lt;- numeric(1e2)\n\nfor(i in 1:100){\n  # Even\n  if (b0%%2 == 0){\n    b0 &lt;- b0/2\n    B[i] = b0\n  }\n  # Odd\n  else{\n    b0 &lt;- 3*b0-1\n    B[i] = b0\n  }\n}\n\nB\n\n\n\n\nWrite a function in R to calculate the sum of the first n natural numbers. Verify your result with the formula \\(\\frac{n(n+1)}{2}\\)\n\n\nCode\nsum_of_natural_num = function(n)\n{\n  # use for loop to access every number and sum them one by one in a varibale \n  sum = 0\n  for (i in 1:n)\n  {\n    sum = sum + i\n  }\n  return(sum)\n}\n\n\n\n\nWrite a function in R to calculate the arithmetic mean of a vector of numbers.\n\n\nCode\narithmetic_mean = function(vec)\n{\n  sum = sum(vec)\n  Ar_mean = sum/length(vec)\n  return(Ar_mean)\n}\n\n# another way\narithmetic_mean &lt;- function(vec) mean(vec)\n\n\n\n\nWrite a function in R to calculate the variance of a vector of numbers. The (sample) variance of observations \\(x_1, x_2, \\dots, x_n\\) is\n\\[\\text{Var}(x_1, x_2, \\dots, x_n) = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2 \\,,\\]\nwhere \\(\\bar{x} = n^{-1} \\sum_{i=1}^{n} x_i\\). Verify with the built-in var() function.\n\n\nCode\ncalculate_variance &lt;- function(x) \n{\n  n &lt;- length(x)\n  mean_x &lt;- mean(x)\n  var_x &lt;- sum((x - mean_x)^2) / (n - 1)  # we can return values direct also \n  return(var_x)\n}\n\ndata &lt;- c(1,5,3,8,6,8,5,4)\ncalculate_variance(data)\nvar(data)\n\n\n\n\nCreate a vector of the first 500 even integers. Then, calculate the product of all elements in this vector.\n\n\nCode\n# this is the vector\neven_seq = seq(from = 2, by = 2 , length.out = 500)\n# product of the elements\nprod(even_seq)\n\n\n\n\nDefine a vector of the first 1000 numbers in :\n\nArithmetic progression of 7 with common difference of 13. That is, create the sequence \\(a_t\\) such that \\(a_1 = 7\\) and \\(a_{t+1} - a_{t} = 13\\) for all \\(t \\geq 1\\).\n\n\nCode\na1 &lt;- 7\nd &lt;- 13\nn &lt;- 1000\narithmetic_progression &lt;- a1 + (0:(n-1)) * d\n\n\nGeometric progression of 7 with common ratio of 1/13. That is, create the sequence \\(a_t\\) such that \\(a_t = 7\\) and \\(a_{t+1}/a_t = 1/13\\)\n\n\nCode\na1 &lt;- 7\nr &lt;- 1/13\ngeometric_progression &lt;- a1 * r^(0:(n-1))\n\n\n\n\n\nWrite a function which generates first n numbers in Fibonacci sequence.\n\n\nCode\nfibonacci_sequence &lt;- function(n) \n{\n  if (n &lt;= 0) {\n    return(\"Enter a natural number\")  \n  } else if (n == 1) {\n    # The first Fibonacci number\n    return(c(0))  \n  } else if (n == 2) {\n    # The first two Fibonacci numbers\n    return(c(0, 1))  \n  }\n\n  # Initialize a vector of length n\n  fib &lt;- numeric(n)  \n  fib[1] &lt;- 0  \n  fib[2] &lt;- 1  \n\n  # Calculate each subsequent Fibonacci number\n  for (i in 3:n) \n  {\n    fib[i] &lt;- fib[i-1] + fib[i-2]  \n  }\n\n  # return the sequence\n  return(fib)\n}\n\n# Example usage:\nfibonacci_sequence(10)\n\n\n\n\nCreate one vector vec1 with \\(1^{st}\\) 8 odd numbers and vec2 with \\(1^{st}\\) 8 Fibonacci numbers(remember to start from zero) and then perform the following operations:\n\nelement-wise multiplication\nelement-wise addition\nelement-wise subtractions (vec1 - vec2)\nelement-wise division\nelements of vec1 raised to the power of elements of vec2\nelements of vec1 modulo elements of vec2\n\n\n\nCode\n# Define vec1 with the first 8 odd numbers using a loop\nvec1 &lt;- numeric(8)\nfor (i in 1:8) \n{\n  vec1[i] &lt;- 2 * i - 1\n}\n\n# Define vec2 with the first 8 Fibonacci numbers using a loop\nvec2 &lt;- numeric(8)\nvec2[1] &lt;- 0\nvec2[2] &lt;- 1\nfor (i in 3:8) \n{\n  vec2[i] &lt;- vec2[i - 1] + vec2[i - 2]\n}\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# a. Element-wise multiplication\nvec_mult &lt;- vec1 * vec2\nvec_mult\n\n# b. Element-wise addition\nvec_add &lt;- vec1 + vec2\nvec_add\n\n# c. Element-wise subtraction\nvec_sub &lt;- vec1 - vec2\nvec_sub\n\n# d. Element-wise division\nvec_div &lt;- vec1 / vec2\nvec_div\n\n# e. Element-wise exponentiation\nvec_exp &lt;- vec1^vec2\nvec_exp\n\n# f. Element-wise modulo operation\nvec_mod &lt;- vec1 %% vec2\nvec_mod\n\n\nDo same as question 3 but now vec2 contains only first 4 Fibonacci numbers rest everything is the same. Will it even work or throw error if works then are there any differences you observe after doing same operations?\n\n\nCode\n{r}\n# Define vec1 with the first 8 odd numbers using a loop\nvec1 &lt;- numeric(8)\nfor (i in 1:8) \n{\n  vec1[i] &lt;- 2 * i - 1\n}\n\n# Define vec2 with the first 4 Fibonacci numbers using a loop\nvec2 &lt;- numeric(4)\nvec2[1] &lt;- 0\nvec2[2] &lt;- 1\nfor (i in 3:4) \n{\n  vec2[i] &lt;- vec2[i - 1] + vec2[i - 2]\n}\n\n\n# NOTICE, NO ERROR!\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# a. Element-wise multiplication\nvec_mult &lt;- vec1 * vec2\nvec_mult\n\n# b. Element-wise addition\nvec_add &lt;- vec1 + vec2\nvec_add\n\n# c. Element-wise subtraction\nvec_sub &lt;- vec1 - vec2\nvec_sub\n\n# d. Element-wise division\nvec_div &lt;- vec1 / vec2\nvec_div\n\n# e. Element-wise exponentiation\nvec_exp &lt;- vec1^vec2\nvec_exp\n\n# f. Element-wise modulo operation\nvec_mod &lt;- vec1 %% vec2\nvec_mod\n\n\nEach new term in the Tribonacci Sequence is generated by adding the previous three terms. By starting with \\(1, 1 \\text{ and } 2\\), and considering the terms in the sequence whose values does not exceed \\(5\\) million, find the sum of all even valued terms.\n\n\nCode\nt1 &lt;- 1\nt2 &lt;- 1\nt3 &lt;- 2\nmx &lt;- 5000000\nadd &lt;- 2\nwhile(TRUE){\n  tn &lt;- t1 + t2 + t3\n  if(tn &gt; mx)\n  {\n    break\n  }\n  if(tn %% 2 == 0)\n  {\n    add &lt;- add + tn\n  }\n  t1 &lt;- t2\n  t2 &lt;- t3\n  t3 &lt;- tn\n}\nadd\n\n\nWrite an R function that takes a numeric vector as input and returns a vector where each element is doubled if it is even, and halved if it is odd.\n\n\nCode\nmodify_vector1 &lt;- function(vec) \n{\n  n &lt;- length(vec)\n  out &lt;- numeric(length = n)\n\n  for(i in 1:n)\n  {\n    if(vec[i] %%2 == 0)\n    {\n      out[i] &lt;- 2*vec[i]\n    } else{\n      out[i] &lt;- vec[i]/2\n    }\n  }\n  return(out)\n}\n\n# another method\nmodify_vector2 &lt;- function(vec)\n{\n  # we can do it in one line using sapply\n  sapply(vec, function(x) if (x %% 2 == 0) x * 2 else x / 2)\n}\n\n# Example usage\nvec &lt;- c(1, 2, 3, 4, 5)\nmodify_vector1(vec)\nmodify_vector2(vec)\n\n\n\n\nWrite a function that takes a numeric vector as input and returns the number of elements that are greater than the mean of the vector\n\n\nCode\ncount_greater_than_mean &lt;- function(vec) \n{\n  mean_val &lt;- mean(vec)\n  sum(vec &gt; mean_val)\n}\n\n# Example usage\nvec &lt;- c(1, 2, 3, 4, 5, 10, 30)\ncount_greater_than_mean(vec)\n\n\n\n\nWrite an R function that generates a vector of the first 100 prime numbers and then returns the vector with only the prime numbers that are also Fibonacci numbers.\n\n\nCode\n# Function to check if prime number\n# if it is divisible by any number other than 1 and itself\nis_prime &lt;- function(n)\n{\n  if (n &lt;= 1) \n  {\n    return(FALSE)\n  }\n  for (i in 2:sqrt(n)) \n  {\n    if (n %% i == 0) \n    {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n\n# Function to generate the first n prime numbers\ngenerate_primes &lt;- function(n)\n{\n  primes &lt;- numeric(n)\n  count &lt;- 0\n  num &lt;- 2\n  while (count &lt; n) \n  {\n    # check if new number is prime or not\n    if (is_prime(num)) \n    {\n      count &lt;- count + 1\n      primes[count] &lt;- num\n    }\n    num &lt;- num + 1\n  }\n  return(primes)\n}\n\n# Function to generate Fibonacci numbers up to a maximum value\ngenerate_fibonacci &lt;- function(max_val) \n{\n  fibs &lt;- c(0, 1)\n  while (TRUE) {\n    next_fib &lt;- tail(fibs, 2)[1] + tail(fibs, 2)[2]\n    if (next_fib &gt; max_val) break\n    fibs &lt;- c(fibs, next_fib)\n  }\n  return(fibs)\n}\n\n# Main function to get prime Fibonacci numbers\nprime_fibonacci_numbers &lt;- function() \n{\n  # Generate the first 100 prime numbers\n  primes &lt;- generate_primes(100)\n\n  # Generate Fibonacci numbers up to the maximum prime value\n  max_prime &lt;- max(primes)\n  fibs &lt;- generate_fibonacci(max_prime)\n\n  # Get prime Fibonacci numbers\n  prime_fibs &lt;- primes[primes %in% fibs]\n\n  return(prime_fibs)\n}"
  },
  {
    "objectID": "vec_and_mat.html#questions",
    "href": "vec_and_mat.html#questions",
    "title": "2  Vectors",
    "section": "2.1 Questions",
    "text": "2.1 Questions\n\nWrite an R code to enumerate the squares of the first 100 natural numbers.\n\n\nCode\nnums &lt;- 1:100\nnums^2   # R is vectorized\n\n\n\n\nA sequence “Dancing Numbers” is defined as follows:\nif \\(B_n\\) is even: \\[\nB_{n+1} = \\dfrac{B_{n}}{2}\n\\]\nelse\n\\[\nB_{n+1} = 3B_n - 1\n\\]\nGenerate the first 100 dancing numbers given \\(B_0\\) is 13.\n\n\nCode\nb0 &lt;- 13\n\nB &lt;- numeric(1e2)\n\nfor(i in 1:100){\n  # Even\n  if (b0%%2 == 0){\n    b0 &lt;- b0/2\n    B[i] = b0\n  }\n  # Odd\n  else{\n    b0 &lt;- 3*b0-1\n    B[i] = b0\n  }\n}\n\nB\n\n\n\n\nWrite a function in R to calculate the sum of the first n natural numbers. Verify your result with the formula \\(\\frac{n(n+1)}{2}\\)\n\n\nCode\nsum_of_natural_num = function(n)\n{\n  # use for loop to access every number and sum them one by one in a varibale \n  sum = 0\n  for (i in 1:n)\n  {\n    sum = sum + i\n  }\n  return(sum)\n}\n\n\n\n\nWrite a function in R to calculate the arithmetic mean of a vector of numbers.\n\n\nCode\narithmetic_mean = function(vec)\n{\n  sum = sum(vec)\n  Ar_mean = sum/length(vec)\n  return(Ar_mean)\n}\n\n# another way\narithmetic_mean &lt;- function(vec) mean(vec)\n\n\n\n\nWrite a function in R to calculate the variance of a vector of numbers. The (sample) variance of observations \\(x_1, x_2, \\dots, x_n\\) is\n\\[\\text{Var}(x_1, x_2, \\dots, x_n) = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2 \\,,\\]\nwhere \\(\\bar{x} = n^{-1} \\sum_{i=1}^{n} x_i\\). Verify with the built-in var() function.\n\n\nCode\ncalculate_variance &lt;- function(x) \n{\n  n &lt;- length(x)\n  mean_x &lt;- mean(x)\n  var_x &lt;- sum((x - mean_x)^2) / (n - 1)  # we can return values direct also \n  return(var_x)\n}\n\ndata &lt;- c(1,5,3,8,6,8,5,4)\ncalculate_variance(data)\nvar(data)\n\n\n\n\nCreate a vector of the first 500 even integers. Then, calculate the product of all elements in this vector.\n\n\nCode\n# this is the vector\neven_seq = seq(from = 2, by = 2 , length.out = 500)\n# product of the elements\nprod(even_seq)\n\n\n\n\nDefine a vector of the first 1000 numbers in :\n\nArithmetic progression of 7 with common difference of 13. That is, create the sequence \\(a_t\\) such that \\(a_1 = 7\\) and \\(a_{t+1} - a_{t} = 13\\) for all \\(t \\geq 1\\).\n\n\nCode\na1 &lt;- 7\nd &lt;- 13\nn &lt;- 1000\narithmetic_progression &lt;- a1 + (0:(n-1)) * d\n\n\nGeometric progression of 7 with common ratio of 1/13. That is, create the sequence \\(a_t\\) such that \\(a_t = 7\\) and \\(a_{t+1}/a_t = 1/13\\)\n\n\nCode\na1 &lt;- 7\nr &lt;- 1/13\ngeometric_progression &lt;- a1 * r^(0:(n-1))\n\n\n\n\n\nWrite a function which generates first n numbers in Fibonacci sequence.\n\n\nCode\nfibonacci_sequence &lt;- function(n) \n{\n  if (n &lt;= 0) {\n    return(\"Enter a natural number\")  \n  } else if (n == 1) {\n    # The first Fibonacci number\n    return(c(0))  \n  } else if (n == 2) {\n    # The first two Fibonacci numbers\n    return(c(0, 1))  \n  }\n\n  # Initialize a vector of length n\n  fib &lt;- numeric(n)  \n  fib[1] &lt;- 0  \n  fib[2] &lt;- 1  \n\n  # Calculate each subsequent Fibonacci number\n  for (i in 3:n) \n  {\n    fib[i] &lt;- fib[i-1] + fib[i-2]  \n  }\n\n  # return the sequence\n  return(fib)\n}\n\n# Example usage:\nfibonacci_sequence(10)\n\n\n\n\nCreate one vector vec1 with \\(1^{st}\\) 8 odd numbers and vec2 with \\(1^{st}\\) 8 Fibonacci numbers(remember to start from zero) and then perform the following operations:\n\nelement-wise multiplication\nelement-wise addition\nelement-wise subtractions (vec1 - vec2)\nelement-wise division\nelements of vec1 raised to the power of elements of vec2\nelements of vec1 modulo elements of vec2\n\n\n\nCode\n# Define vec1 with the first 8 odd numbers using a loop\nvec1 &lt;- numeric(8)\nfor (i in 1:8) \n{\n  vec1[i] &lt;- 2 * i - 1\n}\n\n# Define vec2 with the first 8 Fibonacci numbers using a loop\nvec2 &lt;- numeric(8)\nvec2[1] &lt;- 0\nvec2[2] &lt;- 1\nfor (i in 3:8) \n{\n  vec2[i] &lt;- vec2[i - 1] + vec2[i - 2]\n}\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# a. Element-wise multiplication\nvec_mult &lt;- vec1 * vec2\nvec_mult\n\n# b. Element-wise addition\nvec_add &lt;- vec1 + vec2\nvec_add\n\n# c. Element-wise subtraction\nvec_sub &lt;- vec1 - vec2\nvec_sub\n\n# d. Element-wise division\nvec_div &lt;- vec1 / vec2\nvec_div\n\n# e. Element-wise exponentiation\nvec_exp &lt;- vec1^vec2\nvec_exp\n\n# f. Element-wise modulo operation\nvec_mod &lt;- vec1 %% vec2\nvec_mod\n\n\nDo same as question 3 but now vec2 contains only first 4 Fibonacci numbers rest everything is the same. Will it even work or throw error if works then are there any differences you observe after doing same operations?\n\n\nCode\n{r}\n# Define vec1 with the first 8 odd numbers using a loop\nvec1 &lt;- numeric(8)\nfor (i in 1:8) \n{\n  vec1[i] &lt;- 2 * i - 1\n}\n\n# Define vec2 with the first 4 Fibonacci numbers using a loop\nvec2 &lt;- numeric(4)\nvec2[1] &lt;- 0\nvec2[2] &lt;- 1\nfor (i in 3:4) \n{\n  vec2[i] &lt;- vec2[i - 1] + vec2[i - 2]\n}\n\n\n# NOTICE, NO ERROR!\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# a. Element-wise multiplication\nvec_mult &lt;- vec1 * vec2\nvec_mult\n\n# b. Element-wise addition\nvec_add &lt;- vec1 + vec2\nvec_add\n\n# c. Element-wise subtraction\nvec_sub &lt;- vec1 - vec2\nvec_sub\n\n# d. Element-wise division\nvec_div &lt;- vec1 / vec2\nvec_div\n\n# e. Element-wise exponentiation\nvec_exp &lt;- vec1^vec2\nvec_exp\n\n# f. Element-wise modulo operation\nvec_mod &lt;- vec1 %% vec2\nvec_mod\n\n\nEach new term in the Tribonacci Sequence is generated by adding the previous three terms. By starting with \\(1, 1 \\text{ and } 2\\), and considering the terms in the sequence whose values does not exceed \\(5\\) million, find the sum of all even valued terms.\n\n\nCode\nt1 &lt;- 1\nt2 &lt;- 1\nt3 &lt;- 2\nmx &lt;- 5000000\nadd &lt;- 2\nwhile(TRUE){\n  tn &lt;- t1 + t2 + t3\n  if(tn &gt; mx)\n  {\n    break\n  }\n  if(tn %% 2 == 0)\n  {\n    add &lt;- add + tn\n  }\n  t1 &lt;- t2\n  t2 &lt;- t3\n  t3 &lt;- tn\n}\nadd\n\n\nWrite an R function that takes a numeric vector as input and returns a vector where each element is doubled if it is even, and halved if it is odd.\n\n\nCode\nmodify_vector1 &lt;- function(vec) \n{\n  n &lt;- length(vec)\n  out &lt;- numeric(length = n)\n\n  for(i in 1:n)\n  {\n    if(vec[i] %%2 == 0)\n    {\n      out[i] &lt;- 2*vec[i]\n    } else{\n      out[i] &lt;- vec[i]/2\n    }\n  }\n  return(out)\n}\n\n# another method\nmodify_vector2 &lt;- function(vec)\n{\n  # we can do it in one line using sapply\n  sapply(vec, function(x) if (x %% 2 == 0) x * 2 else x / 2)\n}\n\n# Example usage\nvec &lt;- c(1, 2, 3, 4, 5)\nmodify_vector1(vec)\nmodify_vector2(vec)\n\n\n\n\nWrite a function that takes a numeric vector as input and returns the number of elements that are greater than the mean of the vector\n\n\nCode\ncount_greater_than_mean &lt;- function(vec) \n{\n  mean_val &lt;- mean(vec)\n  sum(vec &gt; mean_val)\n}\n\n# Example usage\nvec &lt;- c(1, 2, 3, 4, 5, 10, 30)\ncount_greater_than_mean(vec)\n\n\n\n\nWrite an R function that generates a vector of the first 100 prime numbers and then returns the vector with only the prime numbers that are also Fibonacci numbers.\n\n\nCode\n# Function to check if prime number\n# if it is divisible by any number other than 1 and itself\nis_prime &lt;- function(n)\n{\n  if (n &lt;= 1) \n  {\n    return(FALSE)\n  }\n  for (i in 2:sqrt(n)) \n  {\n    if (n %% i == 0) \n    {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n\n# Function to generate the first n prime numbers\ngenerate_primes &lt;- function(n)\n{\n  primes &lt;- numeric(n)\n  count &lt;- 0\n  num &lt;- 2\n  while (count &lt; n) \n  {\n    # check if new number is prime or not\n    if (is_prime(num)) \n    {\n      count &lt;- count + 1\n      primes[count] &lt;- num\n    }\n    num &lt;- num + 1\n  }\n  return(primes)\n}\n\n# Function to generate Fibonacci numbers up to a maximum value\ngenerate_fibonacci &lt;- function(max_val) \n{\n  fibs &lt;- c(0, 1)\n  while (TRUE) {\n    next_fib &lt;- tail(fibs, 2)[1] + tail(fibs, 2)[2]\n    if (next_fib &gt; max_val) break\n    fibs &lt;- c(fibs, next_fib)\n  }\n  return(fibs)\n}\n\n# Main function to get prime Fibonacci numbers\nprime_fibonacci_numbers &lt;- function() \n{\n  # Generate the first 100 prime numbers\n  primes &lt;- generate_primes(100)\n\n  # Generate Fibonacci numbers up to the maximum prime value\n  max_prime &lt;- max(primes)\n  fibs &lt;- generate_fibonacci(max_prime)\n\n  # Get prime Fibonacci numbers\n  prime_fibs &lt;- primes[primes %in% fibs]\n\n  return(prime_fibs)\n}"
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "Matrices",
    "section": "",
    "text": "Matrices in R are described by its rows and columns. To define a matrix, we may use the matrix function in R.\n\nmat &lt;- matrix(c(1,5,8,3,4,0), nrow = 3, ncol = 2)\nmat\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    5    4\n[3,]    8    0\n\n\nAccessing elements of the matrix can be done using square brackets (with two index placeholders)\n\nmat[1,2] # first row, 2nd column\n\n[1] 3\n\nmat[3,2]\n\n[1] 0\n\n\n\n\n\nWrite an R snippet to create a \\(10 \\times 10\\) matrix where each entry is the product of it’s row and column number. i.e. \\(A_{i,j} = ij\\).\n\n\nCode\nM &lt;- array(0, dim = c(10,10))\nfor (i in 1:10)\n{\n  for(j in 1:10)\n{\n    M[i,j] = i*j\n  }\n}\n# To check your solution\nM\n\n\nWrite an R snippet that takes in a matrix and returns a vector with all the column sums.\n(Hint: The solution to this problem can be painfully trivial or needlessly complicated.)\n\n\nCode\n# Approach - 1\ncolumn_Sums &lt;- function(M)\n{\n  dims &lt;- dim(M)\n  cols &lt;- dims[2]\n  sums &lt;- numeric(cols)\n  for(i in 1:cols)\n  {\n    sums[i] = sum(M[,i])\n  }\n  return(sums)\n}\n\nM &lt;- array(1:12,dim = c(4,3))\nM # Look at M\n\nsums &lt;- column_Sums(M)\nsums # Look at column sums of M\n\n# Aliter (Lazy approach)\nsums &lt;- colSums(M)\nsums \n\n# Remark: Try a benchmark code on both these solutions to the problem, the result may shock you!\n\n\n\n\nDefine a \\(6 \\times 6\\) matrix where each entry is the sum of random roll of two fair dice.\n\n\nCode\nroll_two_dice &lt;- function()\n{\n  sum_of_rolls &lt;- sum(sample(1:6, 2, replace = TRUE))\n  return(sum_of_rolls)\n}\nvalues &lt;- replicate(36, roll_two_dice())\nanswer &lt;- matrix(values, nrow = 6)\nanswer\n\n\n\nWrite an R function that takes any n x n matrix and returns the sum of the elements in the upper triangular part of the matrix (excluding the diagonal)\n\n\nCode\nsum_upper_triangular &lt;- function(mat) {\n  if (!is.matrix(mat) || nrow(mat) != ncol(mat)) {\n    stop(\"Input must be a square matrix\")\n  }\n\n  n &lt;- nrow(mat)\n  sum_upper &lt;- 0\n\n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      sum_upper &lt;- sum_upper + mat[i, j]\n    }\n  }\n\n  return(sum_upper)\n}\n\n# Example usage\nmat &lt;- matrix(1:25, nrow = 5, ncol = 5)\nmat\nsum_upper_triangular(mat)\n\n\n\n\nDefine a 6×6 matrix with each element being the product of its row and column indices. Extract the submatrix from rows 2 to 4 and columns 3 to 5, and then calculate its inverse.\n\n\nCode\nmat &lt;- matrix(0, nrow = 6, ncol = 6)\nfor (i in 1:6) {\n  for (j in 1:6) {\n    mat[i, j] &lt;- i * j\n  }\n}\n\n# Extract submatrix from rows 2 to 5 and columns 3 to 5\nsubmat &lt;- mat[2:4, 3:5]\n\n# Calculate the inverse of the submatrix\n#inverse_submat &lt;- solve(submat)\n\n# Display the inverse\n#inverse_submat\n\n\n\n\nDefine a 10×10 matrix with all elements being the number 7. Then, replace the diagonal elements with the first 10 powers of 2.\n\n\nCode\n# Create a 10x10 matrix with all elements being 7\nmat &lt;- matrix(7, nrow = 10, ncol = 10)\n\n# Replace diagonal elements with the first 10 powers of 2\ndiag(mat) &lt;- 2^(0:9)\n\n# Display the matrix\nmat\n\n\n\n\nCreate a function in R that takes two matrices as inputs and returns their Hadamard product (element-wise product).\n\n\nCode\nhadamard_product &lt;- function(mat1, mat2) \n{\n  # Check if input matrices are of the same dimensions\n  if (dim(mat1) != dim(mat2)) {\n    stop(\"Input matrices must have the same dimensions\")\n  }\n\n  # Get dimensions of matrices\n  m &lt;- nrow(mat1)\n  n &lt;- ncol(mat1)\n\n  # Initialize result matrix\n  result &lt;- matrix(0, nrow = m, ncol = n)\n\n  # Compute Hadamard product element-wise\n  for (i in 1:m) \n  {\n    for (j in 1:n) \n    {\n      result[i, j] &lt;- mat1[i, j] * mat2[i, j]\n    }\n  }\n\n  return(result)\n}\n\n# Also mat1*mat2 works!\n\n\n\n\nWrite an R function that takes inputs n and ρ. The function should return an n x n identity matrix with ρ added to all non-diagonal elements.\n\n\nCode\nadd_rho_to_identity &lt;- function(n, rho) \n{\n  # Initialize an n x n matrix with zeros\n  mat &lt;- matrix(0, nrow = n, ncol = n)\n\n  # Fill the matrix to create an identity matrix with rho added to non-diagonal elements\n  for (i in 1:n) \n  {\n    for (j in 1:n) \n    {\n      if (i == j) \n      {\n        mat[i, j] &lt;- 1  # Set diagonal elements to 1\n      } else {\n        mat[i, j] &lt;- rho  # Set non-diagonal elements to rho\n      }\n    }\n  }\n\n  return(mat)\n}\n\n\n\n\n\n\n\nWrite an R function that takes a matrix input and returns a smaller matrix with only the intersection of even rows and even columns of the original matrix.\n\n\nCode\nextract_even_rows_even_cols &lt;- function(mat) \n{\n  # Determine dimensions of the input matrix\n  nrow_mat &lt;- nrow(mat)\n  ncol_mat &lt;- ncol(mat)\n\n  # Initialize variables to store indices of even rows and even columns\n  even_rows &lt;- seq(2, nrow_mat, by = 2)\n  even_cols &lt;- seq(2, ncol_mat, by = 2)\n\n  # Extract submatrix containing only even rows and even columns\n  submat &lt;- mat[even_rows, even_cols]\n\n  return(submat)\n}\n\n#You can use for loop too\n\n\n\n\n\n\n\nDefine a 3-dimensional array with dimensions 5 × 5 × 5 where the entries are random normal numbers with mean 0 and standard deviation 1.\n\n\nCode\ngenerate_random_3d_array &lt;- function(dim1 = 5, dim2 = 5, dim3 = 5) \n{\n  # Generate random normal numbers\n  data &lt;- rnorm(dim1 * dim2 * dim3, mean = 0, sd = 1)\n\n  # Create the 3-dimensional array\n  array_3d &lt;- array(data, dim = c(dim1, dim2, dim3))\n\n  return(array_3d)\n}\n\n\n\n\nCreate a \\(100\\times100\\) matrix Mat1 with \\(ij\\)th entry being \\(i\\mod j\\) for \\(i\\geq j\\) else \\(j \\mod i\\). Check via code is the matrix is Symmetric?\n\n\nCode\n{r}\n# Initialize a 100x100 matrix Mat1\nn &lt;- 100\nMat1 &lt;- matrix(0, nrow = n, ncol = n)\n\n# Fill in Mat1 according to the specified rules\nfor (i in 1:n) \n{\n  for (j in 1:n) \n  {\n    if (i &gt;= j) \n    {\n      Mat1[i, j] &lt;- i %% j\n    } else {\n      Mat1[i, j] &lt;- j %% i\n    }\n  }\n}\n\n# Check if Mat1 is symmetric\nall.equal(Mat1, t(Mat1))\n\n\n\n\nCreate a function which given a number n returns a \\(n\\times n\\) matrix in which each \\(i^{th},j^{th}\\) entry is sum of results on rolling a fair die \\((i+j)\\) times.\n\n\nCode\n{r}\nsum_of_throws &lt;- function(k) \n{\n  # Simulate k throws of a fair die (each throw results in a number from 1 to 6)\n  throws &lt;- sample(1:6, k, replace = TRUE)\n\n  # Return the sum of these throws\n  return(sum(throws))\n}\n\n# Function to create an n x n matrix with each (i, j) entry as the sum of i+j dice throws\ndice_sum_matrix &lt;- function(n) \n{\n  # Initialize the n x n matrix\n  matrix_result &lt;- matrix(0, nrow = n, ncol = n)\n\n  # Populate the matrix\n  for (i in 1:n) \n  {\n    for (j in 1:n) \n    {\n      matrix_result[i, j] &lt;- sum_of_throws(i + j)\n    }\n  }\n\n  return(matrix_result)\n}"
  },
  {
    "objectID": "matrices.html#questions",
    "href": "matrices.html#questions",
    "title": "3  Matrices",
    "section": "3.1 Questions",
    "text": "3.1 Questions\n\nWrite an R snippet to create a \\(10 \\times 10\\) matrix where each entry is the product of it’s row and column number. i.e. \\(A_{i,j} = ij\\).\n\n\nCode\nM &lt;- array(0, dim = c(10,10))\nfor (i in 1:10)\n{\n  for(j in 1:10)\n{\n    M[i,j] = i*j\n  }\n}\n# To check your solution\nM\n\n\nWrite an R snippet that takes in a matrix and returns a vector with all the column sums.\n(Hint: The solution to this problem can be painfully trivial or needlessly complicated.)\n\n\nCode\n# Approach - 1\ncolumn_Sums &lt;- function(M)\n{\n  dims &lt;- dim(M)\n  cols &lt;- dims[2]\n  sums &lt;- numeric(cols)\n  for(i in 1:cols)\n  {\n    sums[i] = sum(M[,i])\n  }\n  return(sums)\n}\n\nM &lt;- array(1:12,dim = c(4,3))\nM # Look at M\n\nsums &lt;- column_Sums(M)\nsums # Look at column sums of M\n\n# Aliter (Lazy approach)\nsums &lt;- colSums(M)\nsums \n\n# Remark: Try a benchmark code on both these solutions to the problem, the result may shock you!\n\n\n\n\nDefine a \\(6 \\times 6\\) matrix where each entry is the sum of random roll of two fair dice.\n\n\nCode\nroll_two_dice &lt;- function()\n{\n  sum_of_rolls &lt;- sum(sample(1:6, 2, replace = TRUE))\n  return(sum_of_rolls)\n}\nvalues &lt;- replicate(36, roll_two_dice())\nanswer &lt;- matrix(values, nrow = 6)\nanswer\n\n\nWrite an R function that takes any n x n matrix and returns the sum of the elements in the upper triangular part of the matrix (excluding the diagonal)\n\n\nCode\nsum_upper_triangular &lt;- function(mat) {\n  if (!is.matrix(mat) || nrow(mat) != ncol(mat)) {\n    stop(\"Input must be a square matrix\")\n  }\n\n  n &lt;- nrow(mat)\n  sum_upper &lt;- 0\n\n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      sum_upper &lt;- sum_upper + mat[i, j]\n    }\n  }\n\n  return(sum_upper)\n}\n\n# Example usage\nmat &lt;- matrix(1:25, nrow = 5, ncol = 5)\nmat\nsum_upper_triangular(mat)\n\n\n\n\nDefine a 6×6 matrix with each element being the product of its row and column indices. Extract the submatrix from rows 2 to 4 and columns 3 to 5, and then calculate its inverse.\n\n\nCode\nmat &lt;- matrix(0, nrow = 6, ncol = 6)\nfor (i in 1:6) {\n  for (j in 1:6) {\n    mat[i, j] &lt;- i * j\n  }\n}\n\n# Extract submatrix from rows 2 to 5 and columns 3 to 5\nsubmat &lt;- mat[2:4, 3:5]\n\n# Calculate the inverse of the submatrix\n#inverse_submat &lt;- solve(submat)\n\n# Display the inverse\n#inverse_submat\n\n\n\n\nDefine a 10×10 matrix with all elements being the number 7. Then, replace the diagonal elements with the first 10 powers of 2.\n\n\nCode\n# Create a 10x10 matrix with all elements being 7\nmat &lt;- matrix(7, nrow = 10, ncol = 10)\n\n# Replace diagonal elements with the first 10 powers of 2\ndiag(mat) &lt;- 2^(0:9)\n\n# Display the matrix\nmat\n\n\n\n\nCreate a function in R that takes two matrices as inputs and returns their Hadamard product (element-wise product).\n\n\nCode\nhadamard_product &lt;- function(mat1, mat2) \n{\n  # Check if input matrices are of the same dimensions\n  if (dim(mat1) != dim(mat2)) {\n    stop(\"Input matrices must have the same dimensions\")\n  }\n\n  # Get dimensions of matrices\n  m &lt;- nrow(mat1)\n  n &lt;- ncol(mat1)\n\n  # Initialize result matrix\n  result &lt;- matrix(0, nrow = m, ncol = n)\n\n  # Compute Hadamard product element-wise\n  for (i in 1:m) \n  {\n    for (j in 1:n) \n    {\n      result[i, j] &lt;- mat1[i, j] * mat2[i, j]\n    }\n  }\n\n  return(result)\n}\n\n# Also mat1*mat2 works!\n\n\n\n\nWrite an R function that takes inputs n and ρ. The function should return an n x n identity matrix with ρ added to all non-diagonal elements.\n\n\nCode\nadd_rho_to_identity &lt;- function(n, rho) \n{\n  # Initialize an n x n matrix with zeros\n  mat &lt;- matrix(0, nrow = n, ncol = n)\n\n  # Fill the matrix to create an identity matrix with rho added to non-diagonal elements\n  for (i in 1:n) \n  {\n    for (j in 1:n) \n    {\n      if (i == j) \n      {\n        mat[i, j] &lt;- 1  # Set diagonal elements to 1\n      } else {\n        mat[i, j] &lt;- rho  # Set non-diagonal elements to rho\n      }\n    }\n  }\n\n  return(mat)\n}\n\n\n\n\n\n\n\nWrite an R function that takes a matrix input and returns a smaller matrix with only the intersection of even rows and even columns of the original matrix.\n\n\nCode\nextract_even_rows_even_cols &lt;- function(mat) \n{\n  # Determine dimensions of the input matrix\n  nrow_mat &lt;- nrow(mat)\n  ncol_mat &lt;- ncol(mat)\n\n  # Initialize variables to store indices of even rows and even columns\n  even_rows &lt;- seq(2, nrow_mat, by = 2)\n  even_cols &lt;- seq(2, ncol_mat, by = 2)\n\n  # Extract submatrix containing only even rows and even columns\n  submat &lt;- mat[even_rows, even_cols]\n\n  return(submat)\n}\n\n#You can use for loop too\n\n\n\n\n\n\n\nDefine a 3-dimensional array with dimensions 5 × 5 × 5 where the entries are random normal numbers with mean 0 and standard deviation 1.\n\n\nCode\ngenerate_random_3d_array &lt;- function(dim1 = 5, dim2 = 5, dim3 = 5) \n{\n  # Generate random normal numbers\n  data &lt;- rnorm(dim1 * dim2 * dim3, mean = 0, sd = 1)\n\n  # Create the 3-dimensional array\n  array_3d &lt;- array(data, dim = c(dim1, dim2, dim3))\n\n  return(array_3d)\n}\n\n\n\n\nCreate a \\(100\\times100\\) matrix Mat1 with \\(ij\\)th entry being \\(i\\mod j\\) for \\(i\\geq j\\) else \\(j \\mod i\\). Check via code is the matrix is Symmetric?\n\n\nCode\n{r}\n# Initialize a 100x100 matrix Mat1\nn &lt;- 100\nMat1 &lt;- matrix(0, nrow = n, ncol = n)\n\n# Fill in Mat1 according to the specified rules\nfor (i in 1:n) \n{\n  for (j in 1:n) \n  {\n    if (i &gt;= j) \n    {\n      Mat1[i, j] &lt;- i %% j\n    } else {\n      Mat1[i, j] &lt;- j %% i\n    }\n  }\n}\n\n# Check if Mat1 is symmetric\nall.equal(Mat1, t(Mat1))\n\n\n\n\nCreate a function which given a number n returns a \\(n\\times n\\) matrix in which each \\(i^{th},j^{th}\\) entry is sum of results on rolling a fair die \\((i+j)\\) times.\n\n\nCode\n{r}\nsum_of_throws &lt;- function(k) \n{\n  # Simulate k throws of a fair die (each throw results in a number from 1 to 6)\n  throws &lt;- sample(1:6, k, replace = TRUE)\n\n  # Return the sum of these throws\n  return(sum(throws))\n}\n\n# Function to create an n x n matrix with each (i, j) entry as the sum of i+j dice throws\ndice_sum_matrix &lt;- function(n) \n{\n  # Initialize the n x n matrix\n  matrix_result &lt;- matrix(0, nrow = n, ncol = n)\n\n  # Populate the matrix\n  for (i in 1:n) \n  {\n    for (j in 1:n) \n    {\n      matrix_result[i, j] &lt;- sum_of_throws(i + j)\n    }\n  }\n\n  return(matrix_result)\n}"
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "Functions in R allow use a set of commands that we can keep calling repeatedly. The goal of a function is to fulfill a certain task, typically relying on inputs from a user. The rest of the problems in this short book has many functions that we ask you to write, so here, we start with some simple functions.\n\n\n\nWrite a function to print Hello World if user inputs 1 and Mellow World if user inputs 0\n\n\nCode\nhello_or_mellow &lt;- function(choice)\n{\n  if(choice == 1)\n  {\n    print(\"Hello World\")\n  }\n  if(choice == 0)\n  {\n    print(\"Mellow World \")\n  }\n}\n\n\n\n\nWrite a function to return Hello World if user inputs 1 and Mellow World if user inputs 0. Think about the difference between this function and that previous one.\n\n\nCode\nhello_or_mellow &lt;- function(choice)\n{\n  if(choice == 1)\n  {\n    return(\"Hello World\")\n  }\n  if(choice == 0)\n  {\n    return(\"Mellow World \")\n  }\n}\n\n\n\n\nConsider a scenario where a garden is circular, and you need to calculate the area of the garden. Write an R function that takes the radius of the garden as input and returns the area. How would you modify this function if the garden is elliptical instead of circular?\n\n\nCode\n# Function to calculate area of a circular garden\ncalculate_circular_garden_area &lt;- function(radius) \n{\n  area &lt;- pi * radius^2\n  return(area)\n}\n\n# Function to calculate area of an elliptical garden\ncalculate_elliptical_garden_area &lt;- function(radius1, radius2) {\n  area &lt;- pi * radius1 * radius2\n  return(area)\n}\n\n\n\n\nImagine you have two sets of exam scores, one from the first midterm and the other from the second midterm. Write an R function that takes both sets of scores as inputs and returns the set with the higher average score.\n\n\nCode\ncompare_average_scores &lt;- function(scores1, scores2) \n{\n  if (mean(scores1) &gt; mean(scores2)) \n  {\n    return(scores1)\n  } else {\n    return(scores2)\n  }\n}\n\n\n\n\n(Not a function question) Create two vectors vec1 and vec2, where vec1 contains 1 and Your Name while vec2 contains your JEE Advance/JAM Rank and Answer to the Question as TRUE or FALSE\n\nDootika Ma’am will give all \\(A\\)s in this course\n\nCan such vec1 andvec2 be constructed? If yes, what are the datatype of 1 in vec1, and Answer to the question in vec2? Use typeof() function for finding out.\n\n\nCode\n# Define vec1 with 1 and my name\nvec1 &lt;- c(1, \"Problems\")\n\n# Define vec2 with my JEE Advanced Rank (assuming rank as 10000) and the answer to the question \njee_rank &lt;- 10000  # Replace this with your actual JEE Advanced Rank/ JAM Rank\nanswer &lt;- TRUE   \n\nvec2 &lt;- c(jee_rank, answer)\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# Check the datatype of 1 in vec1\ntypeof(vec1[1])\n\n# Check the datatype of the boolean answer in vec2\ntypeof(vec2[2])"
  },
  {
    "objectID": "functions.html#questions",
    "href": "functions.html#questions",
    "title": "Functions",
    "section": "",
    "text": "Write a function to print Hello World if user inputs 1 and Mellow World if user inputs 0\n\n\nCode\nhello_or_mellow &lt;- function(choice)\n{\n  if(choice == 1)\n  {\n    print(\"Hello World\")\n  }\n  if(choice == 0)\n  {\n    print(\"Mellow World \")\n  }\n}\n\n\n\n\nWrite a function to return Hello World if user inputs 1 and Mellow World if user inputs 0. Think about the difference between this function and that previous one.\n\n\nCode\nhello_or_mellow &lt;- function(choice)\n{\n  if(choice == 1)\n  {\n    return(\"Hello World\")\n  }\n  if(choice == 0)\n  {\n    return(\"Mellow World \")\n  }\n}\n\n\n\n\nConsider a scenario where a garden is circular, and you need to calculate the area of the garden. Write an R function that takes the radius of the garden as input and returns the area. How would you modify this function if the garden is elliptical instead of circular?\n\n\nCode\n# Function to calculate area of a circular garden\ncalculate_circular_garden_area &lt;- function(radius) \n{\n  area &lt;- pi * radius^2\n  return(area)\n}\n\n# Function to calculate area of an elliptical garden\ncalculate_elliptical_garden_area &lt;- function(radius1, radius2) {\n  area &lt;- pi * radius1 * radius2\n  return(area)\n}\n\n\n\n\nImagine you have two sets of exam scores, one from the first midterm and the other from the second midterm. Write an R function that takes both sets of scores as inputs and returns the set with the higher average score.\n\n\nCode\ncompare_average_scores &lt;- function(scores1, scores2) \n{\n  if (mean(scores1) &gt; mean(scores2)) \n  {\n    return(scores1)\n  } else {\n    return(scores2)\n  }\n}\n\n\n\n\n(Not a function question) Create two vectors vec1 and vec2, where vec1 contains 1 and Your Name while vec2 contains your JEE Advance/JAM Rank and Answer to the Question as TRUE or FALSE\n\nDootika Ma’am will give all \\(A\\)s in this course\n\nCan such vec1 andvec2 be constructed? If yes, what are the datatype of 1 in vec1, and Answer to the question in vec2? Use typeof() function for finding out.\n\n\nCode\n# Define vec1 with 1 and my name\nvec1 &lt;- c(1, \"Problems\")\n\n# Define vec2 with my JEE Advanced Rank (assuming rank as 10000) and the answer to the question \njee_rank &lt;- 10000  # Replace this with your actual JEE Advanced Rank/ JAM Rank\nanswer &lt;- TRUE   \n\nvec2 &lt;- c(jee_rank, answer)\n\n# Print vec1 and vec2 to verify\nvec1\nvec2\n\n# Check the datatype of 1 in vec1\ntypeof(vec1[1])\n\n# Check the datatype of the boolean answer in vec2\ntypeof(vec2[2])"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exercises for Learning R",
    "section": "",
    "text": "Preface\nThis is a book with problems that help students learn how to code in R. The problems in this book are typically not going to be data related, but rather problems related to logical coding exercises.\nThe idea of this book comes from having seen many students struggle in introductory coding courses, particularly due to the lack of any coding experience. It is my belief that the best way to learn R, is to do. So this book contains sets of problems towards this goal.\nThe problems (and solutions) in this book are due to the efforts of the following students:\n\nIndraj Prajapat\nRythm Kumar\nSaee Kamat\nSubham Anand\nYash Bihany\nZehaan Naik"
  }
]